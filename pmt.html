let C_FLOW = {Template: 'Dependency Type',
                Nodes:[
 
{Node:{id:'line-break',nom:'cmd'}},
{Node:{id:'heading',nom:'cmd',title:'Dependency Type:S2S'}},   
{Node:{id:4,nom:200,title:'Dependency Type:S2S (A,B,C)',projectStatus:'A',duration: 2,role: 'C',cc: 84,Dependency: []}},
{Node:{id:5,nom:201,title:'B... The predecessor task must have started, before this task can be started',projectStatus:'ForApproval',duration: 2,role: 'C',cc: 68,Dependency: [{id:200,type:'s2s'}]}},
{Node:{id:6,nom:202,title:'C...  The predecessor task must have started, before this task can be started',projectStatus:'ForApproval',duration: 5,role: 'C',cc: 70,Dependency: [{id:201,type:'s2s'}]}},











                ],
                Addressee: [
                  {Department: {id:1,dept:'A',Roles:[
                   {Role: {id : 1, role : 'A1'}}, 
                   {Role: {id : 2, role : 'A2'}}                    
                  ]}},
                  {Department: {id:2,dept:'B',Roles:[
                   {Role: {id : 3, role : 'B'}}, 
                   {Role: {id : 4, role : 'B2'}}  ,
                   {Role: {id : 5, role : 'B3'}}
                  ]}},
                  {Department: {id:3,dept:'C',Roles:[
                   {Role: {id : 6, role : 'C1'}},
                   {Role: {id : 7, role : 'C2'}},               
                   {Role: {id : 8, role : 'C3'}},
                  ]}},
                  {Department: {id:4,dept:'D',Roles:[
                   {Role: {id : 9, role : 'D1'}}                   
                  ]}},
                  {Department: {id:5,dept:'E',Roles:[
                   {Role: {id : 10, role : 'E1'}}       
                  ]}},
                  {Department: {id:6,dept:'F',Roles:[
                   {Role: {id : 11, role : 'F1'}}                   
                  ]}},
                  {Department: {id:7,dept:'F2',Roles:[
                   {Role: {id : 12, role : 'F3'}}                   
                  ]}},
                  {Department: {id:8,dept:'G',Roles:[
                   {Role: {id : 13, role : 'G1'}},
                   {Role: {id : 14, role : 'G2'}},
                   {Role: {id : 15, role : 'G3'}}                      
                  ]}},
                  {Department: {id:9,dept:'J',Roles:[
                   {Role: {id : 16, role : 'J1'}},
                   {Role: {id : 17, role : 'J2'}}     
                  ]}}                  
                   
                ]
               };


var loaded = false;
var c = 100;
const DISPLAYX = C_FLOW.Nodes.length*100;
const DISPLAYY = C_FLOW.Nodes.length*100;
const dependencyLines = [];
function nextColor() {
  c -=5;
  if ( c < 10 ){
    c = 100;
  }
  return ( (c-=5));
}

function assignBaseColor(_flow ) {
 
  for ( let i in _flow.Nodes ){
     _flow.Nodes[i].Node.color =  nextColor();
  }
  return (null);
}

function getNode(_flow, _nom ) {
 
  for ( let i in _flow.Nodes ){
 
    if ( _flow.Nodes[i].Node.nom === _nom){
      return (_flow.Nodes[i].Node);
    }
  }
  return (null);
}
function getNodeByID(_flow, _id ) {
 
  for ( let i in _flow.Nodes ){
 
    if ( _flow.Nodes[i].Node.id === _id){
      return (_flow.Nodes[i].Node);
    }
  }
  return (null);
}

  
function renderTitle( _flow ) {
	push();
	stroke(0);
    textSize(20);
    text(`${_flow.Template}`,10,20	);
	pop();
}


function calcDurationSize( _i, _z = 8 ){
  return (_i*_z);
}
function calcBarLen ( _i, _z = 8){
  return ( _i + _z );
}

function calc_I_PositionOfNode(_o){
  let rad = calcDurationSize(_o.duration);
  let bar = calcBarLen(rad);
  
  return ({
    'position':'I',
    'x':(_o.x),
    'y':(_o.y+bar)
  })
}

function calc_S_PositionOfNode(_o){
  let rad = calcDurationSize(_o.duration);
  let bar = calcBarLen(rad);
  
  return ({
    'position':'S',
    'x':(_o.x-bar),
    'y':(_o.y)
  })
}
function calc_F_PositionOfNode(_o){
  let rad = calcDurationSize(_o.duration);
  let bar = calcBarLen(rad);
  
  return ({
    'position':'F',
    'x':(_o.x+bar),
    'y':(_o.y)
  })
}


function drawNode(_o,_x,_y){
  console.log(`draw ${_o.id}`);
  let rad = calcDurationSize(_o.duration);
  let bar = calcBarLen(rad);
  let txtSize = 8;
  push();
  strokeWeight(0.5);
  stroke(0,0,0);
  translate(_x,_y);
  circle(0,0,rad);
  strokeWeight(0.1);
 
  line(-bar,0,bar,0);
  line(0,0,0,bar);
  strokeWeight(2);
  
 // point(0,-bar); //?
  point(-bar,0); // S
  point(bar,0); // F
  point(0,bar); //I
  
  strokeWeight(1);
  noStroke();
  textWrap(WORD);

  textSize(txtSize);
  text(`${_o.duration}`,0-((textWidth(_o.duration)/2)),0+txtSize/2);
  text(`${_o.id}:${_o.nom}:${_o.title}`,-150,0,150-bar);
  //text(`?`,0+(txtSize/3),-bar+(txtSize/2));
  text(`S`,-bar-(txtSize),0+(txtSize/3));
  text(`F`,bar+(txtSize/3),0+(txtSize/3));
  text(`I`,0+(txtSize/3),bar+(txtSize/3));

  pop();
  console.log(`draw ${_o.id} - done`);
  
}

//Status: Done : Orange
function drawDependencyS2S( _o,_p){
  const c={h:19,s:83,b:98};
  
  if ( _o == undefined || _o == null || _p == undefined || _p == null){
    console.log(`drawDependencyS2S - failed to render dependency. Invalid input`);
    return;
  }
  
  // The predecessor task must have started, before this task can be started
  let s_pos = calc_I_PositionOfNode(_p);
  let e_pos = calc_S_PositionOfNode(_o);
  
  drawDependencyLine(s_pos.x,s_pos.y,e_pos.x,e_pos.y,c.h,c.s,c.b);
  return({
    'key':`${_p.id}-${_o.id}`,
    'dependency_type':'s2s',
    'predecessor':_p.id,
    'current':_o.id,
    'start':s_pos,
    'end':e_pos,
    'color':c
  });
  
}

// Status: Done : GREEN
function drawDependencyS2F( _o,_p){
  const c={h:88,s:83,b:98};
  
  if ( _o == undefined || _o == null || _p == undefined || _p == null){
    console.log(`drawDependencyS2F - failed to render dependency. Invalid input`);
    return;
  }
     // The predecessor task must have started, before this task can be finish
  let s_pos = calc_I_PositionOfNode(_p);
  let e_pos = calc_F_PositionOfNode(_o);
  drawDependencyLine(s_pos.x,s_pos.y,e_pos.x,e_pos.y,c.h,c.s,c.b);
  
  console.log(`\t----------------- [ drawDependencyS2F :${_o.nom} : End ]---------------`);
  return({
    'key':`${_p.id}-${_o.id}`,
    'dependency_type':'s2f',
    'predecessor':_p.id,
    'current':_o.id,
    'start':s_pos,
    'end':e_pos,
    'color':c
  });

}

//Status : Done - Yellow
function drawDependencyF2F( _o,_p){
   const c={h:47,s:83,b:98};
  
  if ( _o == undefined || _o == null || _p == undefined || _p == null){
    console.log(`drawDependencyF2F - failed to render dependency. Invalid input`);
    return;
  }
  
  //predecessor must have finished (submitted) before this task can finish.
  let s_pos = calc_F_PositionOfNode(_p);
  let e_pos = calc_F_PositionOfNode(_o);
  drawDependencyLine(s_pos.x,s_pos.y,e_pos.x,e_pos.y,c.h,c.s,c.b);
  
  return({
    'key':`${_p.id}-${_o.id}`,
    'dependency_type':'f2f',
    'predecessor':_p.id,
    'current':_o.id,
    'start':s_pos,
    'end':e_pos,
    'color':c
  });
  
}

//Status: Blue - Blue
function drawDependencyF2S( _o,_p){
  
   const c={h:230,s:83,b:98};
  
  if ( _o == undefined || _o == null || _p == undefined || _p == null){
    console.log(`drawDependencyF2S - failed to render dependency. Invalid input`);
    return;
  }
    
    // draw from  p:F to o:S
    // get the F position from P
    // get the S position from O
    // render line between the two positions
    // the predecessor task must of Finished, before this task can start
    let s_pos = calc_F_PositionOfNode(_p);
    let e_pos = calc_S_PositionOfNode(_o);
    
    drawDependencyLine(s_pos.x,s_pos.y,e_pos.x,e_pos.y,c.h,c.s,c.b)
  
    return({
    'key':`${_p.id}-${_o.id}`,
    'dependency_type':'f2s',
    'predecessor':_p.id,
    'current':_o.id,
    'start':s_pos,
    'end':e_pos,
    'color':c
  });
  
}

function drawLine(_x0,_y0,_x1,_y1,_h=0,_s=0,_b=0,_sz=2){
  push();
  strokeWeight(_sz);
  stroke(_h,_s,_b);
  line(_x0,_y0,_x1,_y1);
  
  pop();
}

function renderHeading( _title, _x,_y, _h = 0,_s = 0,_b = 0, _sz = 12 ) {
	push();
	stroke(_h,_s,_b);
    textSize(_sz);
    text(`${_title}`,_x,_y	);
	pop();
}

function drawDependencyLine(_x0,_y0,_x1,_y1,_h=0,_s=0,_b=0,_sz=0.3){
  push();
  strokeWeight(_sz);
  stroke(_h,_s,_b);
  line(_x0,_y0,_x1,_y1);
  t = calcArrow(_x0,_y0,_x1,_y1);
  fill(_h,_s,_b);
  
  triangle(t.x,t.y,t.x1,t.y1,t.x2,t.y2);
  
  
  pop();
}

function calcArrow (_startX, _startY, _endX, _endY, _rad = 20, _sz = 10){
      
    let dx = _endX - _startX;
    let dy = _endY - _startY;

    let theta = Math.atan2(dy, dx);

    let rad = radians(_rad); 
    let x = _endX - _sz * Math.cos(theta + rad);
    let y = _endY - _sz * Math.sin(theta + rad);

    let phi2 = radians(-_rad);
    let x2 = _endX - _sz * Math.cos(theta + phi2);
    let y2 = _endY - _sz * Math.sin(theta + phi2);
 
    return ({
      'x':_endX,
      'y':_endY,
      'x1':x,
      'y1':y,
      'x2':x2,
      'y2':y2
    });

}

function isCmdNode(_o){
  let ret = 0;
  switch( _o.id ){
    case 'line-break' :
      ret = 100;
    break;
    case 'heading' :
      ret = 200;
    break;
  }
   
    return (ret);

}

function processCmd(_instruction,_o,_x,_y){
  switch(_instruction){
    case 100://Line break
        drawLine(0,_y,DISPLAYX,_y,0,0,0,2);
      break;
    case 200://Heading
        renderHeading(_o.title,_x,_y,0,0,0,16);
      break;
    default:
      console.log(`illegal command for coded in node ${_o.id}`);
  }
}



function renderNode( _flow, _idx) {
  let hozSpacing = 70;
  let o = _flow.Nodes[_idx].Node;
  let y = 50+(_idx * hozSpacing);
  let x = 150;
  let w = 20 ;
  let h = 20;
  let r = 5;
  let txtSz = 10;
  
  
 
  console.log(`----------------- [ Render id:${o.id} nom:${o.nom} : Start ]---------------`);
  let cmd = isCmdNode(o);
  if (cmd > 0){
    processCmd(cmd,o,x,y);
    return;
  }
  
  drawNode(o,x,y);
  // save position, node is rendered.
  o.x = x;
  o.y = y;
  o.rendered = true;
  
 
  
  // Node is rendered to the screen. and we have stored
  // the X/Y position of the node.  We should now check dep   // and the types of dependency so that we may render the   // the visuals correctly.
  
  for ( let i = 0 ; i < o.Dependency.length ; i++ ){
    let predecessorNodeId = o.Dependency[i].id || null;
    let dependecyType = o.Dependency[i].type || 'f2s';
    let predecessorNode = null;
    
    if (predecessorNodeId != null)
      predecessorNode = getNode(C_FLOW, predecessorNodeId);
    else {
      console.error(`node object for ${predecessorNodeId} not found!`);
      return;
    }
      
    
    let depLine = null;
    if (predecessorNode !== null){  
      switch (dependecyType)
      {
        case 'f2s': 
          depLine=drawDependencyF2S( o, predecessorNode );
          break;
        case 's2s':
          depLine=drawDependencyS2S( o, predecessorNode );
          
          break
        case 's2f':
          depLine=drawDependencyS2F( o, predecessorNode );
          break
        case 'f2f':
          depLine=drawDependencyF2F( o, predecessorNode );
          break
        default:
          console.error(`unknown dependency type for ${predecessorNodeId} in node object ${o.nom}`);
          
      }
      dependencyLines.push(depLine);
      
    } // end if predecessorNode
    
   
    
  }
  
  
  
  
 
  //o.Dependency.length 
  //push();
  //translate(x,y);
  //strokeWeight((o.highlight?2.5:1));
  //textSize(txtSz/1.5);
  //for ( let i = 0 ; i < o.duration; i++ ){
  // A stroke(col,100,100);
  //    stroke(o.color,100,100);
  //    rect(i*w,0,w,h); 
  //    temp.setDate(temp.getDate()+1);
  //stroke(0,0,0,0);
  //  text(`${temp.getDate()}/${temp.getMonth()+1}`,(i*w)+(w/2)-(txtSz/2),(h/2)+(txtSz/2));
  //stroke(0,0,0,0);
  //textSize(txtSz/0.8);
  //text(`${o.nom}:${o.title} - (${o.role})`,0,-3);
  //point(0,0+(h/2));
    
    
  console.log(`----------------- [ Render :${o.nom} : End ]---------------`);
  return ;
   
}


function renderFlow( _flow ) {
  
  for ( let i in _flow.Nodes ){
    renderNode( _flow, i);
  }
}

function reposition( _flow ) {
  let hozSpacing = 70;
  
  let x = 150;
  let w = 20 ;
  let h = 20;
  
  
  /*
  function calcDurationSize( _i, _z = 8 ){
  return (_i*_z);
}
function calcBarLen ( _i, _z = 8){
  return ( _i + _z );
}
  */
    
  for ( let i = 0 ; i < dependencyLines.length ; i++ ) {
    let l = dependencyLines[i];
    let pNode = getNodeByID(C_FLOW,l.predecessor);
    let cNode = getNodeByID(C_FLOW,l.current);
    
    let dType = l.dependency_type;
    
    switch ( dType ) {
      case 's2s':
        let r = calcDurationSize(cNode.duration);
        let b = calcBarLen(cNode.duration);
       
        cNode.x += (b+r) ; // this looks right...just not sure why it is!?
        l.end.x += b+r;
        
        break;
      case 'f2s':
        break;
      case 's2f':
        break;
      case 'f2f':
        break;
    }
    drawDependencyLine(l.start.x,l.start.y,l.end.x,l.end.y,l.color.h,l.color.s,l.color.b);
  }
    
  for ( let i in _flow.Nodes ){
    let o = _flow.Nodes[i].Node;
    
    let y = 50+(i * hozSpacing);
     
    let cmd = isCmdNode(o);
    if (cmd > 0){
      
      processCmd(cmd,o,x,y);
      
    } else {
      
      if (o.rendered)
        drawNode(o,o.x,o.y);
  
    }
  }
  
  
}



function setup(){
  createCanvas(DISPLAYX, DISPLAYY);
  degrees();
  colorMode(HSB);
  assignBaseColor(C_FLOW);
  //renderFlow(C_FLOW);
  //saveCanvas('flow.new..1.dependency', 'png');
  loaded = !loaded;	
  background(220);
  renderTitle(C_FLOW);
  renderFlow(C_FLOW);
  background(220);
  reposition(C_FLOW);
}






function draw() {
  
  
}
